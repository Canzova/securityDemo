â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ’¡ TOPIC: How Spring Security + JWT Checks Roles
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## STEP 1 â€” User sends request with JWT

GET /api/admin/some-data
Authorization: Bearer <JWT>

AuthTokenFilter:

* extracts username
* extracts roles (ROLE_USER, ROLE_ADMIN...)
* validates JWT
* loads user
* creates Authentication object
* saves it into SecurityContext

Example Authentication data:

username = john
roles = [ROLE_ADMIN]

## STEP 2 â€” Spring Security checks roles BEFORE controller

Spring checks:

* What does the endpoint require?
* What roles does user have?

## Example with antMatchers:

.requestMatchers("/api/admin/**").hasRole("ADMIN")

Spring internally checks:
Does Authentication.authorities contain "ROLE_ADMIN"?

## Example with @PreAuthorize:

@PreAuthorize("hasRole('USER')")

Spring checks:
Does Authentication.authorities contain "ROLE_USER"?

If yes â†’ method runs
If no â†’ 403 Forbidden

## STEP 3 â€” Springâ€™s Role Decision Manager

Spring uses:

* AccessDecisionManager
* RoleVoter
* PreInvocationAuthorizationAdvice

These compare:
REQUIRED_ROLES vs USER_ROLES

## WHERE DO ROLES COME FROM?

From the JWT token.

Flow:

1. User logs in
2. Server loads roles and puts them into JWT claims
3. On every request:

   * JWT filter extracts roles
   * Puts them into Authentication object
4. Spring uses that to allow/deny access

## ğŸ FINAL SIMPLE SUMMARY

âœ” JWT filter validates token
âœ” Extracts roles
âœ” Puts Authentication into SecurityContext
âœ” Spring checks roles before calling controller
âœ” If using @PreAuthorize("hasRole('ADMIN')"):
Spring compares required role with roles from JWT

If match â†’ request allowed
If not â†’ 403 Forbidden

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
END OF TXT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ’¡ TOPIC: Why AuthTokenFilter Runs Every Time (JWT is Stateless)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## ğŸ”¥ DOES AuthTokenFilter RUN ON EVERY REQUEST?

Yes.

Every single request goes like this:

1. Request comes with JWT
2. AuthTokenFilter runs
3. Token is validated
4. User details and roles are extracted
5. A new Authentication object is created
6. That Authentication is placed into SecurityContext
7. Controller is called

This happens on EVERY request, not just once.

## ğŸ”¥ WHY IS THIS NECESSARY AND NOT REDUNDANT?

Because JWT is stateless.

Meaning:

* No session stored on server
* No user login data stored on server
* Server does not â€œrememberâ€ past requests
* Server only trusts the JWT sent by client each time

So to authenticate a user:

âœ” The server must verify the token again
âœ” The server must rebuild the Authentication object again
âœ” The server must put it into Spring Security context again

EVERY TIME.

## ğŸ”¥ WHY NOT USE THE SAME AUTH OBJECT FROM LAST REQUEST?

Because HTTP is stateless.

Each request is completely separate from previous ones.

There is no memory between requests unless you store session data.

JWT = NO SERVER SESSION

So the server must re-authenticate using the token every time.

## ğŸ”¥ WHAT IF WE DID NOT REBUILD Authentication EVERY TIME?

Then the server wouldnâ€™t know:

* who the user is
* what roles they have
* whether the token is expired
* whether token was modified
* whether the user was banned since last request

Without rebuilding Authentication:

Spring Security would think the user is anonymous.

## ğŸ”¥ SIMPLE ANALOGY

Think of JWT like a movie ticket.

Every time you enter the theater:

* You must show the ticket again
* The theater staff checks it again
* They donâ€™t store your identity from previous visit

Same with token:
Every request = show ticket again.

## ğŸ FINAL SIMPLE SUMMARY

âœ” Yes â€” AuthTokenFilter runs EVERY time
âœ” Yes â€” Authentication object is created EVERY time
âœ” No â€” it is NOT redundant
âœ” This is REQUIRED because JWT authentication is stateless
âœ” Server does NOT keep any stored session of the user
âœ” Token must be verified on EVERY request
âœ” Authentication must be recreated on EVERY request

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ’¡ TOPIC: Does Spring SecurityContext store user info between requests?
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## SHORT ANSWER

Correct â€” Spring Security does NOT keep user info between requests when using JWT.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ§© HOW IT WORKS WITH JWT (STEP-BY-STEP)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## 1ï¸âƒ£ Request arrives

SecurityContext is empty.

## 2ï¸âƒ£ JWT filter validates the token

* Creates a new Authentication object
* Puts it into SecurityContext

## 3ï¸âƒ£ Controller executes

SecurityContext now contains the user.

## 4ï¸âƒ£ Request ends

Spring automatically clears SecurityContext
(for security reasons).

## 5ï¸âƒ£ Next request arrives

SecurityContext is EMPTY again.
JWT filter must rebuild Authentication again.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”¥ WHY SECURITYCONTEXT IS NOT PERSISTED?
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Because JWT authentication is stateless:

* No HTTP session
* No memory of previous requests
* Server trusts ONLY the JWT that the client sends each time

So each request gets a **fresh SecurityContext**.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¯ SIMPLE ANALOGY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SecurityContext = a whiteboard.

* Start of request â†’ whiteboard is blank
* JWT filter writes user info on it
* After request â†’ Spring erases the board
* Next request â†’ blank again

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ†š SESSION-BASED LOGIN (FOR COMPARISON)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

If you used formLogin() with sessions:

* SecurityContext **would** be stored in the HTTP session
* You would stay logged in
* No need to rebuild Authentication on every request

But with JWT:

âœ” No session
âœ” No stored SecurityContext
âœ” Must rebuild Authentication **every** request

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ FINAL SUMMARY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Yes â€” Spring SecurityContext does NOT store user info after each request when using JWT.

This is expected because JWT is stateless.
Every new request must:

1. Send JWT
2. Validate JWT
3. Recreate Authentication
4. Refill SecurityContext

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
END OF TXT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

